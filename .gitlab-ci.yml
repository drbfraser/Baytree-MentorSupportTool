stages:
  - build
  - deploy

variables:
  DEV_BRANCH: "master"
  STG_BRANCH: "staging"
  PROD_BRANCH: "production"
  IMAGE_BACKEND: "baytree_server"
  IMAGE_FRONTEND: "baytree_revproxy_frontend"

build info:
  # Always runs: allows pipeline execution to happen even if no other tasks run.
  stage: build
  image: alpine:latest
  tags:
    - docker
  rules:
    - if: $CI_PIPELINE_SOURCE != "push"
  script:
    - echo "This task give the CI/CD pipeline something to (almost always) run."
    - echo "  CI_PIPELINE_SOURCE  = $CI_PIPELINE_SOURCE"
    - echo "  CI_MERGE_REQUEST_ID = $CI_MERGE_REQUEST_ID"
    - echo "  CI_COMMIT_BRANCH    = $CI_COMMIT_BRANCH"

build frontend:
  stage: build
  image: node:16
  tags:
    - docker
  rules:
    - if: "$CI_MERGE_REQUEST_ID != null"
      changes:
        - frontend/**/*
        - .gitlab-ci.yml
      when: always
    - if: "$CI_COMMIT_BRANCH == $DEV_BRANCH || $CI_COMMIT_BRANCH == $STG_BRANCH || $CI_COMMIT_BRANCH == $PROD_BRANCH"
      when: always
    # Always build/test for schedule / manual "Run Pipeline" via web
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
  before_script:
    - cd frontend
    - npm ci
  script:
    - GENERATE_SOURCEMAP=false npm run build
  after_script:
    - cd frontend/build && tar -czvf ../../frontend_build.tar.gz .
  artifacts:
    expire_in: 1 week
    paths:
      - frontend_build.tar.gz

build admin-frontend:
  stage: build
  image: node:14
  tags:
    - docker
  rules:
    - if: "$CI_MERGE_REQUEST_ID != null"
      changes:
        - admin-frontend/**/*
        - .gitlab-ci.yml
      when: always
    - if: "$CI_COMMIT_BRANCH == $DEV_BRANCH || $CI_COMMIT_BRANCH == $STG_BRANCH || $CI_COMMIT_BRANCH == $PROD_BRANCH"
      when: always
    # Always build/test for schedule / manual "Run Pipeline" via web
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
  before_script:
    - cd admin-frontend
    - npm ci
  script:
    - GENERATE_SOURCEMAP=false npm run export
  after_script:
    - ls -l admin-frontend
    - cd admin-frontend/build && tar -czvf ../../admin_frontend_build.tar.gz .
  artifacts:
    expire_in: 1 week
    paths:
      - admin_frontend_build.tar.gz

build server:
  stage: build
  image: python:3.9.1-buster
  services:
    - name: mariadb:5.5
      alias: test_mysql
  tags:
    - docker
  needs: []
  rules:
    - if: "$CI_MERGE_REQUEST_ID != null"
      changes:
        - baytree_app/**/*
        - .gitlab-ci.yml
      when: always
    - if: "$CI_COMMIT_BRANCH == $DEV_BRANCH || $CI_COMMIT_BRANCH == $STG_BRANCH || $CI_COMMIT_BRANCH == $PROD_BRANCH"
      when: always
    # Always build/test for schedule / manual "Run Pipeline" via web
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"
  variables:
    DOMAIN: "example.com"
    SECRET_KEY: "test"
    MYSQL_HOST: baytree_database
    MYSQL_DATABASE: baytree
    MYSQL_USER: theuser
    MYSQL_PASSWORD: thepassword
    EMAIL_HOST: ""
    EMAIL_PORT: ""
    EMAIL_USER: ""
    EMAIL_PASSWORD: ""
    VIEWS_USERNAME: ""
    VIEWS_PASSWORD: ""
  before_script:
    - cd baytree_app
  script:
    - pip install -r requirements.txt
    - python manage.py check
    - python manage.py makemigrations --check

.deploy-script: &deploy-script
  - cp /var/baytree/.env ./.env
  - docker-compose -f docker-compose.yml -f docker-compose.deploy.yml build
  - docker-compose -f docker-compose.yml -f docker-compose.deploy.yml up --force-recreate -d
  - docker image prune -f      # remove unused images since we just built new ones
  - bash -c 'sleep 15'
  - docker exec baytree_server python manage.py migrate

deploy development:
  stage: deploy
  environment:
    name: development
    url: https://baytree-dev.cmpt.sfu.ca
  tags:
    - deploy-development
  rules:
    - if: "$CI_COMMIT_BRANCH == $DEV_BRANCH"
      when: on_success
  script:
    - *deploy-script

deploy staging:
  stage: deploy
  environment:
    name: staging
    url: https://baytree-stg.cmpt.sfu.ca
  tags:
    - deploy-staging
  rules:
    - if: "$CI_COMMIT_BRANCH == $STG_BRANCH"
      when: on_success
  script:
    - *deploy-script

deploy dockerhub:
  variables:
    # The following are expected to be defined by GitLab's settings
    #   Docker hub user & token: HUB_USER, HUB_TOKEN
    #   Docker hub projects:     HUB_REPO_FRONTEND, HUB_REPO_BACKEND
  stage: deploy
  tags:
    - deploy-dockerhub-shell
  rules:
    - if: "$CI_COMMIT_BRANCH == $PROD_BRANCH"
      when: manual
  script:
    # Version of the form v2022-12-31.abcd5678, based on date and short SHA1 of last commit on branch
    - export VERSION=v$(git show -s --format=%cs $CI_COMMIT_SHA).`git rev-parse --short=8 $CI_COMMIT_SHA`
    # Show what we are expecting to build / tag
    - echo "Docker Hub configuration       user ='$HUB_USER'     version='$VERSION'"
    - echo "Full tag (backend) is               = $HUB_USER/$HUB_REPO_BACKEND:$VERSION (& ':latest')"
    - echo "Full tag (rev-proxy & frontend) is  = $HUB_USER/$HUB_REPO_FRONTEND:$VERSION (& ':latest')"

    # Build and tag
    - docker-compose -f docker-compose.yml -f docker-compose.deploy.yml build
    - docker tag $IMAGE_BACKEND $HUB_USER/$HUB_REPO_BACKEND:latest
    - docker tag $IMAGE_BACKEND $HUB_USER/$HUB_REPO_BACKEND:$VERSION

    - docker tag $IMAGE_FRONTEND $HUB_USER/$HUB_REPO_FRONTEND:latest
    - docker tag $IMAGE_FRONTEND $HUB_USER/$HUB_REPO_FRONTEND:$VERSION

    # Push images to Docker Hub with the latest and version tags
    - docker images
    - docker login -u $HUB_USER -p $HUB_TOKEN
    - docker push --all-tags $HUB_USER/$HUB_REPO_BACKEND
    - docker push --all-tags $HUB_USER/$HUB_REPO_FRONTEND
    - docker logout

    # Cleanup the image and any tags of that image
    - docker images -a | grep -e "$IMAGE_BACKEND" -e "$IMAGE_FRONTEND" | awk '{print $3}' | xargs docker rmi --force
    - docker images
